<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yìí˜• ë”¸ê¸° ìŠ¤ë§ˆíŠ¸íŒœ ì‹œë®¬ë ˆì´ì…˜ (Ver 2.5 - ë°ì´í„° ë¶„ì„)</title>
    <style>
        body {
            font-family: 'Nanum Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f4f8;
            margin: 0;
            padding: 20px;
        }
        h2 {
            color: #2c3e50;
            margin-bottom: 5px;
        }
        p.subtitle {
            color: #666;
            font-size: 0.9rem;
            margin-top: 0;
            margin-bottom: 20px;
        }
        .canvas-container {
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            background-color: #87CEEB;
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        .controls {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 900px;
        }
        .control-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-weight: bold;
            color: #555;
            min-width: 90px;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 140px;
            cursor: pointer;
        }
        .value-display {
            min-width: 80px;
            text-align: right;
            color: #007bff;
            font-weight: bold;
            font-size: 0.9em;
        }
        .legend {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        .analysis-section {
            width: 900px;
            margin-top: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .analysis-title {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        table.stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            text-align: center;
        }
        table.stats-table th {
            background-color: #f8f9fa;
            color: #555;
            padding: 10px;
            border-bottom: 2px solid #ddd;
        }
        table.stats-table td {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        /* Color coding for table cells based on light hours */
        .good-light { color: #27ae60; font-weight: bold; }
        .med-light { color: #e67e22; font-weight: bold; }
        .bad-light { color: #c0392b; font-weight: bold; }
        
        .warning-msg {
            color: #e74c3c;
            font-weight: bold;
            font-size: 0.9em;
            display: none;
        }
    </style>
</head>
<body>

    <h2>â˜€ï¸ Yìí˜• ë”¸ê¸° ìŠ¤ë§ˆíŠ¸íŒœ ì‹œë®¬ë ˆì´ì…˜ (Ver 2.5)</h2>
    <p class="subtitle">* ìœ„ì¹˜ë³„ ì¼ì¡° ì‹œê°„(Hours) ìë™ ê³„ì‚° ë° ì •ë°€ ìˆ˜ì¹˜ ë¶„ì„ ê¸°ëŠ¥ íƒ‘ì¬</p>

    <div class="canvas-container">
        <canvas id="farmCanvas" width="940" height="600"></canvas>
    </div>

    <div class="controls">
        <!-- Sun & Season Control -->
        <div class="control-row" style="background-color: #fff3cd; padding: 15px; border-radius: 5px;">
            <div class="control-group">
                <label>ğŸ“… ì›”(Month)</label>
                <input type="range" id="month" min="1" max="12" step="1" value="12">
                <span class="value-display" id="val-month">12ì›” (ë™ì§€)</span>
            </div>
            <div class="control-group">
                <label>â° í˜„ì¬ ì‹œê°</label>
                <input type="range" id="sunTime" min="8" max="16" step="0.1" value="12">
                <span class="value-display" id="val-sunTime">12:00</span>
            </div>
        </div>

        <!-- House & Bed Settings -->
        <div class="control-row">
            <div class="control-group">
                <label>ğŸ  í•˜ìš°ìŠ¤ ë†’ì´</label>
                <input type="range" id="houseHeight" min="3.0" max="5.0" step="0.1" value="4.0">
                <span class="value-display" id="val-houseHeight">4.0m</span>
            </div>
            <div class="control-group">
                <label>ğŸ›ï¸ ë² ë“œ ë†’ì´</label>
                <input type="range" id="bedHeight" min="10" max="100" step="5" value="35">
                <span class="value-display" id="val-bedHeight">35cm</span>
            </div>
        </div>

        <!-- Layout Settings -->
        <div class="control-row">
            <div class="control-group">
                <label>ì—´ ê°œìˆ˜</label>
                <input type="range" id="rows" min="3" max="6" step="1" value="4">
                <span class="value-display" id="val-rows">4ì—´</span>
            </div>
            <div class="control-group">
                <label>ë² ë“œ ê°„ê²©</label>
                <input type="range" id="rowSpacing" min="100" max="250" step="5" value="170">
                <span class="value-display" id="val-rowSpacing">170cm</span>
            </div>
        </div>
        
        <!-- Pot & Pipe Settings -->
        <div class="control-row">
            <div class="control-group">
                <label>í™”ë¶„ ë‹¨ ê°„ê²©</label>
                <input type="range" id="potSpacingY" min="20" max="60" step="5" value="40">
                <span class="value-display" id="val-potSpacingY">40cm</span>
            </div>
            <div class="control-group">
                <label>íŒŒì´í”„ ë‘ê»˜</label>
                <input type="range" id="pipeThickness" min="20" max="200" step="5" value="30">
                <span class="value-display" id="val-pipeThickness">30mm</span>
            </div>
            <div class="control-group">
                <label>ğŸ‘¨â€ğŸŒ¾ ì‚¬ëŒ í‚¤</label>
                <input type="range" id="humanHeight" min="150" max="190" step="1" value="175">
                <span class="value-display" id="val-humanHeight">175cm</span>
            </div>
        </div>

        <div class="control-row" style="justify-content: space-between; width: 100%;">
            <div id="width-warning" class="warning-msg">âš ï¸ ì£¼ì˜: ë² ë“œ ê°„ê²©ì´ ë„ˆë¬´ ë„“ì–´ í•˜ìš°ìŠ¤ í­ì„ ì´ˆê³¼í•©ë‹ˆë‹¤!</div>
        </div>
    </div>

    <!-- Analysis Table -->
    <div class="analysis-section">
        <div class="analysis-title">ğŸ“Š ìƒì„¸ ê´‘ëŸ‰ ë¦¬í¬íŠ¸ (ì¼ì¼ ì¼ì¡° ì‹œê°„: 08:00 ~ 16:00 ê¸°ì¤€)</div>
        <table class="stats-table" id="statsTable">
            <thead>
                <tr>
                    <th rowspan="2">ìœ„ì¹˜</th>
                    <th colspan="2">ìƒë‹¨ (3ë‹¨)</th>
                    <th colspan="2">ì¤‘ë‹¨ (2ë‹¨)</th>
                    <th colspan="2">í•˜ë‹¨ (1ë‹¨)</th>
                </tr>
                <tr>
                    <th>ì¢Œ (Left)</th>
                    <th>ìš° (Right)</th>
                    <th>ì¢Œ (Left)</th>
                    <th>ìš° (Right)</th>
                    <th>ì¢Œ (Left)</th>
                    <th>ìš° (Right)</th>
                </tr>
            </thead>
            <tbody id="statsBody">
                <!-- Javascript will populate this -->
            </tbody>
        </table>
        <div style="margin-top: 10px; font-size: 0.85em; text-align: right; color: #666;">
            * <span class="good-light">ì´ˆë¡ìƒ‰: 4ì‹œê°„ ì´ìƒ (ìš°ìˆ˜)</span> | 
            <span class="med-light">ì£¼í™©ìƒ‰: 2~4ì‹œê°„ (ë³´í†µ)</span> | 
            <span class="bad-light">ë¹¨ê°„ìƒ‰: 2ì‹œê°„ ë¯¸ë§Œ (ë¶€ì¡±)</span>
        </div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="color-box" style="background:#e74c3c;"></div> ìˆ˜ê´‘(ì–‘í˜¸)</div>
        <div class="legend-item"><div class="color-box" style="background:#555;"></div> ê·¸ëŠ˜(ë¶€ì¡±)</div>
        <div class="legend-item"><div class="color-box" style="background:#3498db;"></div> Yì í™”ë¶„</div>
        <div class="legend-item"><div class="color-box" style="background:#2c3e50;"></div> ì¤‘ì•™ íŒŒì´í”„</div>
    </div>

    <script>
        const canvas = document.getElementById('farmCanvas');
        const ctx = canvas.getContext('2d');
        const statsBody = document.getElementById('statsBody');
        const warningMsg = document.getElementById('width-warning');
        
        // Scale: 1 meter = 80 pixels
        const SCALE = 80; 
        const GROUND_Y = 550; 
        const HOUSE_WIDTH_M = 8.3;
        const LATITUDE = 36.5; 
        
        const params = {
            houseHeight: 4.0, 
            bedHeight: 35, 
            humanHeight: 175, 
            shoulderHeight: 2.2, 
            rows: 4,          
            rowSpacing: 170,  
            potSpacingY: 40,  
            pipeThickness: 30,
            sunTime: 12.0,
            month: 12
        };

        const inputs = {
            sunTime: document.getElementById('sunTime'),
            month: document.getElementById('month'),
            rows: document.getElementById('rows'),
            rowSpacing: document.getElementById('rowSpacing'),
            potSpacingY: document.getElementById('potSpacingY'),
            pipeThickness: document.getElementById('pipeThickness'),
            humanHeight: document.getElementById('humanHeight'),
            houseHeight: document.getElementById('houseHeight'),
            bedHeight: document.getElementById('bedHeight')
        };

        const displays = {
            sunTime: document.getElementById('val-sunTime'),
            month: document.getElementById('val-month'),
            rows: document.getElementById('val-rows'),
            rowSpacing: document.getElementById('val-rowSpacing'),
            potSpacingY: document.getElementById('val-potSpacingY'),
            pipeThickness: document.getElementById('val-pipeThickness'),
            humanHeight: document.getElementById('val-humanHeight'),
            houseHeight: document.getElementById('val-houseHeight'),
            bedHeight: document.getElementById('val-bedHeight')
        };

        // Data Storage for Daily Stats
        // stats[row][tier][side] -> hours
        let dailyStats = [];

        // Mouse Drag Logic
        let humanX = 100;
        let isDragging = false;

        // Init
        Object.keys(inputs).forEach(key => {
            inputs[key].addEventListener('input', (e) => {
                params[key] = parseFloat(e.target.value);
                updateDisplay(key);
                // If geometry or month changes, re-calculate daily stats
                if (key !== 'sunTime' && key !== 'humanHeight') {
                    calculateDailyStats();
                }
                draw();
            });
        });

        function updateDisplay(key) {
            if (key === 'sunTime') {
                const h = Math.floor(params[key]);
                const m = Math.round((params[key] - h) * 60);
                displays[key].innerText = `${h}:${m < 10 ? '0'+m : m}`;
            }
            else if (key === 'month') {
                const m = params[key];
                let season = "";
                if(m == 12 || m <= 2) season = "(ê²¨ìš¸/ë™ì§€)";
                else if(m >= 6 && m <= 8) season = "(ì—¬ë¦„/í•˜ì§€)";
                else season = "(ë´„/ê°€ì„)";
                displays[key].innerText = `${m}ì›” ${season}`;
            }
            else if (key === 'rows') displays[key].innerText = params[key] + 'ì—´';
            else if (key === 'rowSpacing') displays[key].innerText = params[key] + 'cm';
            else if (key === 'potSpacingY') displays[key].innerText = params[key] + 'cm';
            else if (key === 'pipeThickness') displays[key].innerText = params[key] + 'mm';
            else if (key === 'humanHeight') displays[key].innerText = params[key] + 'cm';
            else if (key === 'houseHeight') displays[key].innerText = params[key].toFixed(1) + 'm';
            else if (key === 'bedHeight') displays[key].innerText = params[key] + 'cm';
        }

        // --- Solar Calculation Core (Pure Function) ---
        function getSunPosition(hour, month) {
            const latRad = LATITUDE * (Math.PI / 180);
            
            // Declination
            const dayOfYear = (month - 1) * 30 + 15; 
            const declinationDeg = 23.45 * Math.sin((360 / 365) * (dayOfYear - 81) * (Math.PI / 180));
            const declinationRad = declinationDeg * (Math.PI / 180);

            // Hour Angle
            const hourAngleDeg = (hour - 12) * 15; 
            const hourAngleRad = hourAngleDeg * (Math.PI / 180);

            // Elevation
            const sinElev = Math.sin(latRad) * Math.sin(declinationRad) + 
                            Math.cos(latRad) * Math.cos(declinationRad) * Math.cos(hourAngleRad);
            const elevRad = Math.asin(sinElev);
            const elevDeg = elevRad * (Math.PI / 180);

            // Azimuth
            const cosAz = (Math.sin(declinationRad) - Math.sin(latRad) * Math.sin(elevRad)) / 
                          (Math.cos(elevRad) * Math.cos(latRad));
            let azRad = Math.acos(Math.min(Math.max(cosAz, -1), 1));
            if (hour < 12) azRad = -azRad; 

            // 2D Projection Vectors
            const vecE = Math.cos(elevRad) * Math.sin(azRad);
            const vecU = Math.sin(elevRad);

            return { vecE, vecU, elevDeg };
        }

        // --- Daily Stats Calculation ---
        function calculateDailyStats() {
            // Reset stats structure
            dailyStats = [];
            for(let r=0; r<params.rows; r++) {
                let rowData = [];
                for(let t=0; t<3; t++) { // 3 tiers
                    rowData.push({ left: 0, right: 0 }); // accumulators
                }
                dailyStats.push(rowData);
            }

            const startHour = 8;
            const endHour = 16;
            const step = 0.5; // 30 mins

            // Temporary obstacles generator for calculation
            const tempObstacles = generateObstacles(canvas.width/2); 

            for(let t = startHour; t <= endHour; t += step) {
                const sun = getSunPosition(t, params.month);
                if (sun.vecU <= 0) continue; // Night

                // For each point, check shading
                // We need coordinate logic similar to draw()
                // Let's reuse generateObstacles logic to get coordinates of plants
                
                // Re-calculate target points based on obstacles
                // Obstacles array contains plants as 'circle'
                
                // Optimized: The obstacles array already has coordinates relative to CENTER X.
                // We just need to check lighting for each plant obstacle.
                
                // Note: generateObstacles relies on 'obstacles' global or return?
                // Let's use the return value.
                
                for(let obs of tempObstacles) {
                    if(obs.type === 'circle') {
                        // Check if this plant is lit at time t
                        const isLit = checkLightingForPoint(obs.x, obs.y, obs.row, sun, tempObstacles);
                        if(isLit) {
                            // Map obs index to stats structure
                            // obs doesn't store tier index directly, but we can infer or store it.
                            // Let's add tier index to obstacle generation for easier mapping.
                            // Added 'tier' and 'side' ('left'/'right') to generateObstacles
                            
                            if(obs.side === 'left') dailyStats[obs.row][obs.tier].left += step;
                            else dailyStats[obs.row][obs.tier].right += step;
                        }
                    }
                }
            }
            
            updateStatsTable();
        }

        function checkLightingForPoint(tx, ty, myRowIdx, sun, obstacleList) {
            // Ray Casting Logic
            // Sun Vector: dx = vecE, dy = -vecU (up is negative Y)
            const ux = sun.vecE;
            const uy = -sun.vecU; 
            
            for (let obs of obstacleList) {
                if (obs.type === 'circle') {
                    if (obs.row === myRowIdx && Math.abs(obs.x - tx) < 10) continue; 
                    
                    const vObsX = obs.x - tx;
                    const vObsY = obs.y - ty;
                    // Project vObs onto Ray(u)
                    // Ray is not normalized here, but vecE/vecU are unit-ish? 
                    // Let's calculate dot product direction.
                    
                    // Normalize U for calculation
                    const uLen = Math.sqrt(ux*ux + uy*uy);
                    const nUx = ux / uLen;
                    const nUy = uy / uLen;
                    
                    const dot = vObsX * nUx + vObsY * nUy;
                    
                    if (dot > 0) { // Object is in front
                        // Perpendicular distance
                        const projX = tx + nUx * dot;
                        const projY = ty + nUy * dot;
                        const distToLine = Math.sqrt((obs.x - projX)**2 + (obs.y - projY)**2);
                        if (distToLine < obs.r) return false;
                    }
                } 
                else if (obs.type === 'rect') {
                    // Simple Ray-Rect Intersection
                    const rx = obs.x; const ry = obs.y; const rw = obs.w; const rh = obs.h;
                    // Check intersection... (Simplified Slab)
                    // (Same logic as draw loop, reused)
                    let tMin = 0; let tMax = 99999;
                    
                    if (Math.abs(ux) < 1e-6) { if (tx < rx || tx > rx + rw) continue; }
                    else {
                        let t1 = (rx - tx) / ux; let t2 = ((rx + rw) - tx) / ux;
                        if (t1 > t2) [t1, t2] = [t2, t1];
                        tMin = Math.max(tMin, t1); tMax = Math.min(tMax, t2);
                    }
                    if (tMin > tMax) continue;
                    
                    if (Math.abs(uy) < 1e-6) { if (ty < ry || ty > ry + rh) continue; }
                    else {
                        let t1 = (ry - ty) / uy; let t2 = ((ry + rh) - ty) / uy;
                        if (t1 > t2) [t1, t2] = [t2, t1];
                        tMin = Math.max(tMin, t1); tMax = Math.min(tMax, t2);
                    }
                    
                    if (tMin > tMax) continue;
                    if (tMin > 1) return false; 
                }
            }
            return true;
        }

        function generateObstacles(centerX) {
            let list = [];
            const bedH_px = (params.bedHeight / 100) * SCALE;
            const tierGap_px = (params.potSpacingY / 100) * SCALE;
            const potBaseY = GROUND_Y - bedH_px;
            const pipeThickPx = (params.pipeThickness / 1000) * SCALE;
            const pipeHalf = pipeThickPx / 2;

            for (let i = 0; i < params.rows; i++) {
                const spacingPx = (params.rowSpacing / 100) * SCALE;
                const totalW = (params.rows - 1) * spacingPx;
                const startX = centerX - totalW / 2;
                const cx = startX + i * spacingPx;
                
                const armLen = 30; 
                const leafR = 12; 
                
                for(let tier=0; tier<3; tier++) {
                    const yPos = potBaseY - 20 - (tierGap_px * tier);
                    // Add tier index and side for tracking
                    list.push({ type: 'circle', x: cx - armLen, y: yPos, r: leafR, row: i, tier: tier, side: 'left' });
                    list.push({ type: 'circle', x: cx + armLen, y: yPos, r: leafR, row: i, tier: tier, side: 'right' });
                }
                
                const topY = potBaseY - 20 - (tierGap_px * 2);
                list.push({ type: 'rect', x: cx - pipeHalf, y: topY, w: pipeThickPx, h: (potBaseY - topY), row: i });
            }
            return list;
        }

        function updateStatsTable() {
            statsBody.innerHTML = '';
            
            // Format hours helper
            const fmt = (h) => h.toFixed(1) + 'h';
            const cls = (h) => h >= 4 ? 'good-light' : (h >= 2 ? 'med-light' : 'bad-light');

            for(let r=0; r<params.rows; r++) {
                const row = document.createElement('tr');
                
                // Row Header
                const th = document.createElement('th');
                th.innerText = (r+1) + "ì—´";
                row.appendChild(th);
                
                // Cells: Top(2), Mid(1), Bot(0) -> Array indices. 
                // Display Order: Top(2), Mid(1), Bot(0).
                // Indices: Left, Right
                
                // Tier 3 (idx 2)
                row.innerHTML += `<td class="${cls(dailyStats[r][2].left)}">${fmt(dailyStats[r][2].left)}</td>`;
                row.innerHTML += `<td class="${cls(dailyStats[r][2].right)}">${fmt(dailyStats[r][2].right)}</td>`;
                
                // Tier 2 (idx 1)
                row.innerHTML += `<td class="${cls(dailyStats[r][1].left)}">${fmt(dailyStats[r][1].left)}</td>`;
                row.innerHTML += `<td class="${cls(dailyStats[r][1].right)}">${fmt(dailyStats[r][1].right)}</td>`;
                
                // Tier 1 (idx 0)
                row.innerHTML += `<td class="${cls(dailyStats[r][0].left)}">${fmt(dailyStats[r][0].left)}</td>`;
                row.innerHTML += `<td class="${cls(dailyStats[r][0].right)}">${fmt(dailyStats[r][0].right)}</td>`;
                
                statsBody.appendChild(row);
            }
        }

        // --- Drawing Loop ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const housePixelWidth = HOUSE_WIDTH_M * SCALE;
            const leftWallX = centerX - housePixelWidth / 2;
            const rightWallX = centerX + housePixelWidth / 2;
            
            // Draw Sky
            const month = params.month;
            const isWinter = (month >= 11 || month <= 2);
            ctx.fillStyle = isWinter ? '#D6EAF8' : '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, GROUND_Y);
            
            // Width Check
            const totalWidth = (params.rows - 1) * params.rowSpacing + 60;
            if ((totalWidth / 100) > HOUSE_WIDTH_M) warningMsg.style.display = 'block';
            else warningMsg.style.display = 'none';
            
            // Generate Obstacles for current frame
            obstacles = generateObstacles(centerX);
            
            drawGreenhouse(leftWallX, rightWallX);
            drawSunAndRays();
            drawRows(centerX);
            drawHuman(humanX); 
            drawDimensions(leftWallX, rightWallX);
        }

        function drawRows(centerX) {
            // Re-calc positions for drawing
            const spacingPx = (params.rowSpacing / 100) * SCALE;
            const totalW = (params.rows - 1) * spacingPx;
            const startX = centerX - totalW / 2;
            
            // Current Sun for Instant Shadow
            const curSun = getSunPosition(params.sunTime, params.month);

            for (let i = 0; i < params.rows; i++) {
                const cx = startX + i * spacingPx;
                drawYPotSystem(cx, i, curSun);
            }
        }

        function drawYPotSystem(cx, rowIdx, sun) {
            const bedH_px = (params.bedHeight / 100) * SCALE;
            const tierGap_px = (params.potSpacingY / 100) * SCALE;
            const pipeThickPx = (params.pipeThickness / 1000) * SCALE;
            
            // Bed
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(cx - 5, GROUND_Y - bedH_px, 10, bedH_px); 
            ctx.fillRect(cx - 20, GROUND_Y - bedH_px, 40, 5);    

            // Pipe
            const potBaseY = GROUND_Y - bedH_px;
            const potTopY = potBaseY - 20 - tierGap_px * 2;
            ctx.fillStyle = '#2c3e50'; 
            ctx.fillRect(cx - pipeThickPx/2, potTopY, pipeThickPx, (potBaseY - potTopY));
            
            // Tiers
            drawTier(cx, potBaseY - 20, 0, rowIdx, sun);
            drawTier(cx, potBaseY - 20 - tierGap_px, 1, rowIdx, sun);
            drawTier(cx, potBaseY - 20 - tierGap_px * 2, 2, rowIdx, sun);
        }

        function drawTier(cx, y, tierIdx, rowIdx, sun) {
            const armLen = 30; 
            
            // Instant Lighting Check
            const leftLit = (sun.vecU > 0) && checkLightingForPoint(cx - armLen, y - 10, rowIdx, sun, obstacles);
            const rightLit = (sun.vecU > 0) && checkLightingForPoint(cx + armLen, y - 10, rowIdx, sun, obstacles);

            // Draw Structure
            ctx.beginPath();
            ctx.moveTo(cx, y + 10); 
            ctx.quadraticCurveTo(cx - 10, y + 5, cx - armLen, y - 10);
            ctx.moveTo(cx, y + 10);
            ctx.quadraticCurveTo(cx + 10, y + 5, cx + armLen, y - 10);
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 4; ctx.stroke();

            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath(); ctx.arc(cx - armLen, y - 10, 8, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx + armLen, y - 10, 8, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

            // Plants
            drawLeaves(cx - armLen, y - 10, leftLit);
            drawLeaves(cx + armLen, y - 10, rightLit);
            drawStrawberry(cx - armLen - 5, y - 5, leftLit);
            drawStrawberry(cx + armLen + 5, y - 5, rightLit);
            
            // Draw Stats Text (Daily Hours)
            if(dailyStats.length > 0) {
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#333';
                
                // Left Stat
                const lHours = dailyStats[rowIdx][tierIdx].left.toFixed(1);
                ctx.fillText(lHours + 'h', cx - armLen - 20, y - 5);
                
                // Right Stat
                const rHours = dailyStats[rowIdx][tierIdx].right.toFixed(1);
                ctx.fillText(rHours + 'h', cx + armLen + 20, y - 5);
            }
        }

        function drawLeaves(x, y, isLit) {
            ctx.fillStyle = isLit ? '#27ae60' : '#34495e'; 
            ctx.beginPath(); ctx.ellipse(x, y - 10, 12, 6, Math.PI / 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x, y - 10, 12, 6, -Math.PI / 4, 0, Math.PI * 2); ctx.fill();
        }

        function drawStrawberry(x, y, isLit) {
            ctx.fillStyle = isLit ? '#e74c3c' : '#5c2b29'; 
            ctx.beginPath(); ctx.moveTo(x, y);
            ctx.bezierCurveTo(x + 5, y + 2, x + 5, y + 10, x, y + 15);
            ctx.bezierCurveTo(x - 5, y + 10, x - 5, y + 2, x, y);
            ctx.fill();
        }

        // --- Common Draw Functions ---
        function drawSunAndRays() {
            const sun = getSunPosition(params.sunTime, params.month);
            const sunDist = 500;
            const cx = canvas.width/2; const cy = GROUND_Y;
            const sx = cx + sun.vecE * sunDist; const sy = cy - sun.vecU * sunDist;

            ctx.beginPath(); ctx.arc(sx, sy, 40, 0, Math.PI * 2);
            ctx.fillStyle = '#f1c40f'; ctx.fill();
            
            if(sun.vecU > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.15)'; ctx.lineWidth = 1;
                for(let i=0; i<=12; i++) {
                    ctx.beginPath(); ctx.moveTo(sx, sy);
                    ctx.lineTo(canvas.width*(i/12), GROUND_Y); ctx.stroke();
                }
            }
        }

        function drawGreenhouse(x1, x2) {
            ctx.beginPath(); ctx.moveTo(x1, GROUND_Y);
            const shH = params.shoulderHeight * SCALE;
            ctx.lineTo(x1, GROUND_Y - shH);
            const pkH = params.houseHeight * SCALE;
            const px = (x1 + x2) / 2;
            const py = GROUND_Y - pkH;
            ctx.quadraticCurveTo(px, py - 50, x2, GROUND_Y - shH);
            ctx.lineTo(x2, GROUND_Y); ctx.lineTo(x1, GROUND_Y);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fill();
            ctx.strokeStyle = '#34495e'; ctx.lineWidth = 3; ctx.stroke();
            
            ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(canvas.width, GROUND_Y);
            ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 2; ctx.stroke();
        }

        function drawHuman(x) {
            const hH_px = (params.humanHeight / 100) * SCALE;
            const headR = hH_px / 8;
            const bodyH = hH_px * 0.4;
            const legH = hH_px * 0.45;
            const startY = GROUND_Y - legH - bodyH - headR * 2;

            ctx.beginPath(); ctx.arc(x, startY + headR, headR, 0, Math.PI * 2);
            ctx.fillStyle = '#f1c40f'; ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#3498db'; ctx.fillRect(x - headR, startY + headR * 2, headR * 2, bodyH);
            ctx.fillStyle = '#2c3e50'; 
            ctx.fillRect(x - headR + 2, startY + headR * 2 + bodyH, headR - 3, legH);
            ctx.fillRect(x + 2, startY + headR * 2 + bodyH, headR - 3, legH);
        }

        function drawDimensions(x1, x2) {
            ctx.beginPath(); ctx.moveTo(x1, GROUND_Y + 30); ctx.lineTo(x2, GROUND_Y + 30);
            ctx.strokeStyle = 'black'; ctx.stroke();
            ctx.fillStyle = 'black'; ctx.font = '14px sans-serif'; 
            ctx.fillText(`í•˜ìš°ìŠ¤ í­ ${HOUSE_WIDTH_M}m`, (x1 + x2) / 2 - 40, GROUND_Y + 45);
        }

        // Drag handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const hH_px = (params.humanHeight / 100) * SCALE;
            if (x > humanX - 30 && x < humanX + 30 && y > GROUND_Y - hH_px - 20) {
                isDragging = true; canvas.style.cursor = 'grabbing';
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                humanX = e.clientX - rect.left;
                if(humanX < 50) humanX = 50; if(humanX > canvas.width - 50) humanX = canvas.width - 50;
                draw();
            } else {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const hH_px = (params.humanHeight / 100) * SCALE;
                if (x > humanX - 30 && x < humanX + 30 && y > GROUND_Y - hH_px - 20) canvas.style.cursor = 'grab';
                else canvas.style.cursor = 'default';
            }
        });
        canvas.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'default'; });

        // Initial Calculation
        calculateDailyStats();
        draw(); 

    </script>
</body>
</html>